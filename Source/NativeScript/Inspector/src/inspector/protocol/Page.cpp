// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/inspector/protocol/Page.h"

#include "src/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol\crdtp/cbor.h"
#include "third_party/inspector_protocol\crdtp/find_by_first.h"
#include "third_party/inspector_protocol\crdtp/span.h"

namespace v8_inspector {
namespace protocol {
namespace Page {

using v8_crdtp::DeserializerState;
using v8_crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Page";
const char Metainfo::commandPrefix[] = "Page.";
const char Metainfo::version[] = "1.3";


V8_CRDTP_BEGIN_DESERIALIZER(Frame)
    V8_CRDTP_DESERIALIZE_FIELD("id", m_id),
    V8_CRDTP_DESERIALIZE_FIELD("loaderId", m_loaderId),
    V8_CRDTP_DESERIALIZE_FIELD("mimeType", m_mimeType),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("name", m_name),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("parentId", m_parentId),
    V8_CRDTP_DESERIALIZE_FIELD("securityOrigin", m_securityOrigin),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("unreachableUrl", m_unreachableUrl),
    V8_CRDTP_DESERIALIZE_FIELD("url", m_url),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("urlFragment", m_urlFragment),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Frame)
    V8_CRDTP_SERIALIZE_FIELD("id", m_id);
    V8_CRDTP_SERIALIZE_FIELD("parentId", m_parentId);
    V8_CRDTP_SERIALIZE_FIELD("loaderId", m_loaderId);
    V8_CRDTP_SERIALIZE_FIELD("name", m_name);
    V8_CRDTP_SERIALIZE_FIELD("url", m_url);
    V8_CRDTP_SERIALIZE_FIELD("urlFragment", m_urlFragment);
    V8_CRDTP_SERIALIZE_FIELD("securityOrigin", m_securityOrigin);
    V8_CRDTP_SERIALIZE_FIELD("mimeType", m_mimeType);
    V8_CRDTP_SERIALIZE_FIELD("unreachableUrl", m_unreachableUrl);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(FrameResource)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("canceled", m_canceled),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("contentSize", m_contentSize),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("failed", m_failed),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("lastModified", m_lastModified),
    V8_CRDTP_DESERIALIZE_FIELD("mimeType", m_mimeType),
    V8_CRDTP_DESERIALIZE_FIELD("type", m_type),
    V8_CRDTP_DESERIALIZE_FIELD("url", m_url),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(FrameResource)
    V8_CRDTP_SERIALIZE_FIELD("url", m_url);
    V8_CRDTP_SERIALIZE_FIELD("type", m_type);
    V8_CRDTP_SERIALIZE_FIELD("mimeType", m_mimeType);
    V8_CRDTP_SERIALIZE_FIELD("lastModified", m_lastModified);
    V8_CRDTP_SERIALIZE_FIELD("contentSize", m_contentSize);
    V8_CRDTP_SERIALIZE_FIELD("failed", m_failed);
    V8_CRDTP_SERIALIZE_FIELD("canceled", m_canceled);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(FrameResourceTree)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("childFrames", m_childFrames),
    V8_CRDTP_DESERIALIZE_FIELD("frame", m_frame),
    V8_CRDTP_DESERIALIZE_FIELD("resources", m_resources),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(FrameResourceTree)
    V8_CRDTP_SERIALIZE_FIELD("frame", m_frame);
    V8_CRDTP_SERIALIZE_FIELD("childFrames", m_childFrames);
    V8_CRDTP_SERIALIZE_FIELD("resources", m_resources);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(FrameTree)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("childFrames", m_childFrames),
    V8_CRDTP_DESERIALIZE_FIELD("frame", m_frame),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(FrameTree)
    V8_CRDTP_SERIALIZE_FIELD("frame", m_frame);
    V8_CRDTP_SERIALIZE_FIELD("childFrames", m_childFrames);
V8_CRDTP_END_SERIALIZER();



V8_CRDTP_BEGIN_DESERIALIZER(LayoutViewport)
    V8_CRDTP_DESERIALIZE_FIELD("clientHeight", m_clientHeight),
    V8_CRDTP_DESERIALIZE_FIELD("clientWidth", m_clientWidth),
    V8_CRDTP_DESERIALIZE_FIELD("pageX", m_pageX),
    V8_CRDTP_DESERIALIZE_FIELD("pageY", m_pageY),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(LayoutViewport)
    V8_CRDTP_SERIALIZE_FIELD("pageX", m_pageX);
    V8_CRDTP_SERIALIZE_FIELD("pageY", m_pageY);
    V8_CRDTP_SERIALIZE_FIELD("clientWidth", m_clientWidth);
    V8_CRDTP_SERIALIZE_FIELD("clientHeight", m_clientHeight);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(VisualViewport)
    V8_CRDTP_DESERIALIZE_FIELD("clientHeight", m_clientHeight),
    V8_CRDTP_DESERIALIZE_FIELD("clientWidth", m_clientWidth),
    V8_CRDTP_DESERIALIZE_FIELD("offsetX", m_offsetX),
    V8_CRDTP_DESERIALIZE_FIELD("offsetY", m_offsetY),
    V8_CRDTP_DESERIALIZE_FIELD("pageX", m_pageX),
    V8_CRDTP_DESERIALIZE_FIELD("pageY", m_pageY),
    V8_CRDTP_DESERIALIZE_FIELD("scale", m_scale),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("zoom", m_zoom),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(VisualViewport)
    V8_CRDTP_SERIALIZE_FIELD("offsetX", m_offsetX);
    V8_CRDTP_SERIALIZE_FIELD("offsetY", m_offsetY);
    V8_CRDTP_SERIALIZE_FIELD("pageX", m_pageX);
    V8_CRDTP_SERIALIZE_FIELD("pageY", m_pageY);
    V8_CRDTP_SERIALIZE_FIELD("clientWidth", m_clientWidth);
    V8_CRDTP_SERIALIZE_FIELD("clientHeight", m_clientHeight);
    V8_CRDTP_SERIALIZE_FIELD("scale", m_scale);
    V8_CRDTP_SERIALIZE_FIELD("zoom", m_zoom);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(Viewport)
    V8_CRDTP_DESERIALIZE_FIELD("height", m_height),
    V8_CRDTP_DESERIALIZE_FIELD("scale", m_scale),
    V8_CRDTP_DESERIALIZE_FIELD("width", m_width),
    V8_CRDTP_DESERIALIZE_FIELD("x", m_x),
    V8_CRDTP_DESERIALIZE_FIELD("y", m_y),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Viewport)
    V8_CRDTP_SERIALIZE_FIELD("x", m_x);
    V8_CRDTP_SERIALIZE_FIELD("y", m_y);
    V8_CRDTP_SERIALIZE_FIELD("width", m_width);
    V8_CRDTP_SERIALIZE_FIELD("height", m_height);
    V8_CRDTP_SERIALIZE_FIELD("scale", m_scale);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(FontFamilies)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("cursive", m_cursive),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("fantasy", m_fantasy),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("fixed", m_fixed),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pictograph", m_pictograph),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("sansSerif", m_sansSerif),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("serif", m_serif),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("standard", m_standard),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(FontFamilies)
    V8_CRDTP_SERIALIZE_FIELD("standard", m_standard);
    V8_CRDTP_SERIALIZE_FIELD("fixed", m_fixed);
    V8_CRDTP_SERIALIZE_FIELD("serif", m_serif);
    V8_CRDTP_SERIALIZE_FIELD("sansSerif", m_sansSerif);
    V8_CRDTP_SERIALIZE_FIELD("cursive", m_cursive);
    V8_CRDTP_SERIALIZE_FIELD("fantasy", m_fantasy);
    V8_CRDTP_SERIALIZE_FIELD("pictograph", m_pictograph);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(FontSizes)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("fixed", m_fixed),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("standard", m_standard),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(FontSizes)
    V8_CRDTP_SERIALIZE_FIELD("standard", m_standard);
    V8_CRDTP_SERIALIZE_FIELD("fixed", m_fixed);
V8_CRDTP_END_SERIALIZER();


namespace ClientNavigationReasonEnum {
const char FormSubmissionGet[] = "formSubmissionGet";
const char FormSubmissionPost[] = "formSubmissionPost";
const char HttpHeaderRefresh[] = "httpHeaderRefresh";
const char ScriptInitiated[] = "scriptInitiated";
const char MetaTagRefresh[] = "metaTagRefresh";
const char PageBlockInterstitial[] = "pageBlockInterstitial";
const char Reload[] = "reload";
} // namespace ClientNavigationReasonEnum


// ------------- Enum values from params.


namespace CaptureScreenshot {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
const char* Mhtml = "mhtml";
} // namespace FormatEnum
} // namespace CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
const char* ReturnAsBase64 = "ReturnAsBase64";
const char* ReturnAsStream = "ReturnAsStream";
} // namespace TransferModeEnum
} // namespace PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
const char* Deny = "deny";
const char* Allow = "allow";
const char* Default = "default";
} // namespace BehaviorEnum
} // namespace SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
const char* Mobile = "mobile";
const char* Desktop = "desktop";
} // namespace ConfigurationEnum
} // namespace SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
const char* Frozen = "frozen";
const char* Active = "active";
} // namespace StateEnum
} // namespace SetWebLifecycleState

namespace FileChooserOpened {
namespace ModeEnum {
const char* SelectSingle = "selectSingle";
const char* SelectMultiple = "selectMultiple";
} // namespace ModeEnum
} // namespace FileChooserOpened

namespace FrameScheduledNavigation {
namespace ReasonEnum {
const char* FormSubmissionGet = "formSubmissionGet";
const char* FormSubmissionPost = "formSubmissionPost";
const char* HttpHeaderRefresh = "httpHeaderRefresh";
const char* ScriptInitiated = "scriptInitiated";
const char* MetaTagRefresh = "metaTagRefresh";
const char* PageBlockInterstitial = "pageBlockInterstitial";
const char* Reload = "reload";
} // namespace ReasonEnum
} // namespace FrameScheduledNavigation

// ------------- Frontend notifications.

void Frontend::domContentEventFired(double timestamp)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.domContentEventFired", serializer.Finish()));
}

void Frontend::fileChooserOpened(const String& frameId, int backendNodeId, const String& mode)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("backendNodeId"), backendNodeId);
    serializer.AddField(v8_crdtp::MakeSpan("mode"), mode);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.fileChooserOpened", serializer.Finish()));
}

void Frontend::frameAttached(const String& frameId, const String& parentFrameId, Maybe<protocol::Runtime::StackTrace> stack)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("parentFrameId"), parentFrameId);
    serializer.AddField(v8_crdtp::MakeSpan("stack"), stack);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameAttached", serializer.Finish()));
}

void Frontend::frameClearedScheduledNavigation(const String& frameId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameClearedScheduledNavigation", serializer.Finish()));
}

void Frontend::frameDetached(const String& frameId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameDetached", serializer.Finish()));
}

void Frontend::frameNavigated(std::unique_ptr<protocol::Page::Frame> frame)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frame"), frame);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameNavigated", serializer.Finish()));
}

void Frontend::frameResized()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameResized"));
}

void Frontend::frameRequestedNavigation(const String& frameId, const String& reason, const String& url)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("reason"), reason);
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameRequestedNavigation", serializer.Finish()));
}

void Frontend::frameScheduledNavigation(const String& frameId, double delay, const String& reason, const String& url)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("delay"), delay);
    serializer.AddField(v8_crdtp::MakeSpan("reason"), reason);
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameScheduledNavigation", serializer.Finish()));
}

void Frontend::frameStartedLoading(const String& frameId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameStartedLoading", serializer.Finish()));
}

void Frontend::frameStoppedLoading(const String& frameId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.frameStoppedLoading", serializer.Finish()));
}

void Frontend::downloadWillBegin(const String& frameId, const String& url)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.downloadWillBegin", serializer.Finish()));
}

void Frontend::lifecycleEvent(const String& frameId, const String& loaderId, const String& name, double timestamp)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(v8_crdtp::MakeSpan("name"), name);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.lifecycleEvent", serializer.Finish()));
}

void Frontend::loadEventFired(double timestamp)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.loadEventFired", serializer.Finish()));
}

void Frontend::navigatedWithinDocument(const String& frameId, const String& url)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.navigatedWithinDocument", serializer.Finish()));
}

void Frontend::windowOpen(const String& url, const String& windowName, std::unique_ptr<protocol::Array<String>> windowFeatures, bool userGesture)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    serializer.AddField(v8_crdtp::MakeSpan("windowName"), windowName);
    serializer.AddField(v8_crdtp::MakeSpan("windowFeatures"), windowFeatures);
    serializer.AddField(v8_crdtp::MakeSpan("userGesture"), userGesture);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.windowOpen", serializer.Finish()));
}

void Frontend::compilationCacheProduced(const String& url, const Binary& data)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    serializer.AddField(v8_crdtp::MakeSpan("data"), data);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Page.compilationCacheProduced", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const v8_crdtp::Dispatchable& dispatchable);

    std::function<void(const v8_crdtp::Dispatchable&)> Dispatch(v8_crdtp::span<uint8_t> command_name) override;

    void addScriptToEvaluateOnLoad(const v8_crdtp::Dispatchable& dispatchable);
    void addScriptToEvaluateOnNewDocument(const v8_crdtp::Dispatchable& dispatchable);
    void createIsolatedWorld(const v8_crdtp::Dispatchable& dispatchable);
    void disable(const v8_crdtp::Dispatchable& dispatchable);
    void enable(const v8_crdtp::Dispatchable& dispatchable);
    void getInstallabilityErrors(const v8_crdtp::Dispatchable& dispatchable);
    void getManifestIcons(const v8_crdtp::Dispatchable& dispatchable);
    void getFrameTree(const v8_crdtp::Dispatchable& dispatchable);
    void getLayoutMetrics(const v8_crdtp::Dispatchable& dispatchable);
    void getResourceContent(const v8_crdtp::Dispatchable& dispatchable);
    void getResourceTree(const v8_crdtp::Dispatchable& dispatchable);
    void reload(const v8_crdtp::Dispatchable& dispatchable);
    void removeScriptToEvaluateOnLoad(const v8_crdtp::Dispatchable& dispatchable);
    void removeScriptToEvaluateOnNewDocument(const v8_crdtp::Dispatchable& dispatchable);
    void searchInResource(const v8_crdtp::Dispatchable& dispatchable);
    void setAdBlockingEnabled(const v8_crdtp::Dispatchable& dispatchable);
    void setBypassCSP(const v8_crdtp::Dispatchable& dispatchable);
    void setFontFamilies(const v8_crdtp::Dispatchable& dispatchable);
    void setFontSizes(const v8_crdtp::Dispatchable& dispatchable);
    void setDocumentContent(const v8_crdtp::Dispatchable& dispatchable);
    void setLifecycleEventsEnabled(const v8_crdtp::Dispatchable& dispatchable);
    void startScreencast(const v8_crdtp::Dispatchable& dispatchable);
    void stopLoading(const v8_crdtp::Dispatchable& dispatchable);
    void stopScreencast(const v8_crdtp::Dispatchable& dispatchable);
    void setProduceCompilationCache(const v8_crdtp::Dispatchable& dispatchable);
    void addCompilationCache(const v8_crdtp::Dispatchable& dispatchable);
    void clearCompilationCache(const v8_crdtp::Dispatchable& dispatchable);
    void generateTestReport(const v8_crdtp::Dispatchable& dispatchable);
    void waitForDebugger(const v8_crdtp::Dispatchable& dispatchable);
    void setInterceptFileChooserDialog(const v8_crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(v8_crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<v8_crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          v8_crdtp::SpanFrom("addCompilationCache"),
          &DomainDispatcherImpl::addCompilationCache
    },
    {
          v8_crdtp::SpanFrom("addScriptToEvaluateOnLoad"),
          &DomainDispatcherImpl::addScriptToEvaluateOnLoad
    },
    {
          v8_crdtp::SpanFrom("addScriptToEvaluateOnNewDocument"),
          &DomainDispatcherImpl::addScriptToEvaluateOnNewDocument
    },
    {
          v8_crdtp::SpanFrom("clearCompilationCache"),
          &DomainDispatcherImpl::clearCompilationCache
    },
    {
          v8_crdtp::SpanFrom("createIsolatedWorld"),
          &DomainDispatcherImpl::createIsolatedWorld
    },
    {
          v8_crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          v8_crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          v8_crdtp::SpanFrom("generateTestReport"),
          &DomainDispatcherImpl::generateTestReport
    },
    {
          v8_crdtp::SpanFrom("getFrameTree"),
          &DomainDispatcherImpl::getFrameTree
    },
    {
          v8_crdtp::SpanFrom("getInstallabilityErrors"),
          &DomainDispatcherImpl::getInstallabilityErrors
    },
    {
          v8_crdtp::SpanFrom("getLayoutMetrics"),
          &DomainDispatcherImpl::getLayoutMetrics
    },
    {
          v8_crdtp::SpanFrom("getManifestIcons"),
          &DomainDispatcherImpl::getManifestIcons
    },
    {
          v8_crdtp::SpanFrom("getResourceContent"),
          &DomainDispatcherImpl::getResourceContent
    },
    {
          v8_crdtp::SpanFrom("getResourceTree"),
          &DomainDispatcherImpl::getResourceTree
    },
    {
          v8_crdtp::SpanFrom("reload"),
          &DomainDispatcherImpl::reload
    },
    {
          v8_crdtp::SpanFrom("removeScriptToEvaluateOnLoad"),
          &DomainDispatcherImpl::removeScriptToEvaluateOnLoad
    },
    {
          v8_crdtp::SpanFrom("removeScriptToEvaluateOnNewDocument"),
          &DomainDispatcherImpl::removeScriptToEvaluateOnNewDocument
    },
    {
          v8_crdtp::SpanFrom("searchInResource"),
          &DomainDispatcherImpl::searchInResource
    },
    {
          v8_crdtp::SpanFrom("setAdBlockingEnabled"),
          &DomainDispatcherImpl::setAdBlockingEnabled
    },
    {
          v8_crdtp::SpanFrom("setBypassCSP"),
          &DomainDispatcherImpl::setBypassCSP
    },
    {
          v8_crdtp::SpanFrom("setDocumentContent"),
          &DomainDispatcherImpl::setDocumentContent
    },
    {
          v8_crdtp::SpanFrom("setFontFamilies"),
          &DomainDispatcherImpl::setFontFamilies
    },
    {
          v8_crdtp::SpanFrom("setFontSizes"),
          &DomainDispatcherImpl::setFontSizes
    },
    {
          v8_crdtp::SpanFrom("setInterceptFileChooserDialog"),
          &DomainDispatcherImpl::setInterceptFileChooserDialog
    },
    {
          v8_crdtp::SpanFrom("setLifecycleEventsEnabled"),
          &DomainDispatcherImpl::setLifecycleEventsEnabled
    },
    {
          v8_crdtp::SpanFrom("setProduceCompilationCache"),
          &DomainDispatcherImpl::setProduceCompilationCache
    },
    {
          v8_crdtp::SpanFrom("startScreencast"),
          &DomainDispatcherImpl::startScreencast
    },
    {
          v8_crdtp::SpanFrom("stopLoading"),
          &DomainDispatcherImpl::stopLoading
    },
    {
          v8_crdtp::SpanFrom("stopScreencast"),
          &DomainDispatcherImpl::stopScreencast
    },
    {
          v8_crdtp::SpanFrom("waitForDebugger"),
          &DomainDispatcherImpl::waitForDebugger
    },
    };
    return commands;
  }();
  return v8_crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const v8_crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(v8_crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const v8_crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct addScriptToEvaluateOnLoadParams : public v8_crdtp::DeserializableProtocolObject<addScriptToEvaluateOnLoadParams> {
    String scriptSource;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(addScriptToEvaluateOnLoadParams)
    V8_CRDTP_DESERIALIZE_FIELD("scriptSource", scriptSource),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addScriptToEvaluateOnLoad(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addScriptToEvaluateOnLoadParams params;
    addScriptToEvaluateOnLoadParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_identifier;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addScriptToEvaluateOnLoad(params.scriptSource, &out_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.addScriptToEvaluateOnLoad"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("identifier"), out_identifier);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct addScriptToEvaluateOnNewDocumentParams : public v8_crdtp::DeserializableProtocolObject<addScriptToEvaluateOnNewDocumentParams> {
    String source;
    Maybe<String> worldName;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(addScriptToEvaluateOnNewDocumentParams)
    V8_CRDTP_DESERIALIZE_FIELD("source", source),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("worldName", worldName),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addScriptToEvaluateOnNewDocument(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addScriptToEvaluateOnNewDocumentParams params;
    addScriptToEvaluateOnNewDocumentParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_identifier;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addScriptToEvaluateOnNewDocument(params.source, std::move(params.worldName), &out_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.addScriptToEvaluateOnNewDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("identifier"), out_identifier);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct createIsolatedWorldParams : public v8_crdtp::DeserializableProtocolObject<createIsolatedWorldParams> {
    String frameId;
    Maybe<String> worldName;
    Maybe<bool> grantUniveralAccess;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(createIsolatedWorldParams)
    V8_CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("grantUniveralAccess", grantUniveralAccess),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("worldName", worldName),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::createIsolatedWorld(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    createIsolatedWorldParams params;
    createIsolatedWorldParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_executionContextId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->createIsolatedWorld(params.frameId, std::move(params.worldName), std::move(params.grantUniveralAccess), &out_executionContextId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.createIsolatedWorld"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("executionContextId"), out_executionContextId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::enable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getInstallabilityErrors(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_errors;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getInstallabilityErrors(&out_errors);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.getInstallabilityErrors"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("errors"), out_errors);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getManifestIcons(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    Maybe<Binary> out_primaryIcon;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getManifestIcons(&out_primaryIcon);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.getManifestIcons"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("primaryIcon"), out_primaryIcon);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getFrameTree(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Page::FrameTree> out_frameTree;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFrameTree(&out_frameTree);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.getFrameTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("frameTree"), out_frameTree);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getLayoutMetrics(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Page::LayoutViewport> out_layoutViewport;
    std::unique_ptr<protocol::Page::VisualViewport> out_visualViewport;
    std::unique_ptr<protocol::DOM::Rect> out_contentSize;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getLayoutMetrics(&out_layoutViewport, &out_visualViewport, &out_contentSize);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.getLayoutMetrics"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("layoutViewport"), out_layoutViewport);
          serializer.AddField(v8_crdtp::MakeSpan("visualViewport"), out_visualViewport);
          serializer.AddField(v8_crdtp::MakeSpan("contentSize"), out_contentSize);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

class GetResourceContentCallbackImpl : public Backend::GetResourceContentCallback, public DomainDispatcher::Callback {
public:
    GetResourceContentCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Page.getResourceContent"), message) { }

    void sendSuccess(const String& content, bool base64Encoded) override
    {
        v8_crdtp::ObjectSerializer serializer;
        serializer.AddField(v8_crdtp::MakeSpan("content"), content);
        serializer.AddField(v8_crdtp::MakeSpan("base64Encoded"), base64Encoded);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getResourceContentParams : public v8_crdtp::DeserializableProtocolObject<getResourceContentParams> {
    String frameId;
    String url;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getResourceContentParams)
    V8_CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    V8_CRDTP_DESERIALIZE_FIELD("url", url),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getResourceContent(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getResourceContentParams params;
    getResourceContentParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    m_backend->getResourceContent(params.frameId, params.url, std::make_unique<GetResourceContentCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {


}  // namespace

void DomainDispatcherImpl::getResourceTree(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Page::FrameResourceTree> out_frameTree;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getResourceTree(&out_frameTree);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.getResourceTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("frameTree"), out_frameTree);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct reloadParams : public v8_crdtp::DeserializableProtocolObject<reloadParams> {
    Maybe<bool> ignoreCache;
    Maybe<String> scriptToEvaluateOnLoad;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(reloadParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("ignoreCache", ignoreCache),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("scriptToEvaluateOnLoad", scriptToEvaluateOnLoad),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::reload(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    reloadParams params;
    reloadParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->reload(std::move(params.ignoreCache), std::move(params.scriptToEvaluateOnLoad));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.reload"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeScriptToEvaluateOnLoadParams : public v8_crdtp::DeserializableProtocolObject<removeScriptToEvaluateOnLoadParams> {
    String identifier;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(removeScriptToEvaluateOnLoadParams)
    V8_CRDTP_DESERIALIZE_FIELD("identifier", identifier),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeScriptToEvaluateOnLoad(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeScriptToEvaluateOnLoadParams params;
    removeScriptToEvaluateOnLoadParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeScriptToEvaluateOnLoad(params.identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.removeScriptToEvaluateOnLoad"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeScriptToEvaluateOnNewDocumentParams : public v8_crdtp::DeserializableProtocolObject<removeScriptToEvaluateOnNewDocumentParams> {
    String identifier;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(removeScriptToEvaluateOnNewDocumentParams)
    V8_CRDTP_DESERIALIZE_FIELD("identifier", identifier),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeScriptToEvaluateOnNewDocument(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeScriptToEvaluateOnNewDocumentParams params;
    removeScriptToEvaluateOnNewDocumentParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeScriptToEvaluateOnNewDocument(params.identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.removeScriptToEvaluateOnNewDocument"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SearchInResourceCallbackImpl : public Backend::SearchInResourceCallback, public DomainDispatcher::Callback {
public:
    SearchInResourceCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Page.searchInResource"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Debugger::SearchMatch>> result) override
    {
        v8_crdtp::ObjectSerializer serializer;
        serializer.AddField(v8_crdtp::MakeSpan("result"), result);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct searchInResourceParams : public v8_crdtp::DeserializableProtocolObject<searchInResourceParams> {
    String frameId;
    String url;
    String query;
    Maybe<bool> caseSensitive;
    Maybe<bool> isRegex;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(searchInResourceParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("caseSensitive", caseSensitive),
    V8_CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("isRegex", isRegex),
    V8_CRDTP_DESERIALIZE_FIELD("query", query),
    V8_CRDTP_DESERIALIZE_FIELD("url", url),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::searchInResource(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    searchInResourceParams params;
    searchInResourceParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    m_backend->searchInResource(params.frameId, params.url, params.query, std::move(params.caseSensitive), std::move(params.isRegex), std::make_unique<SearchInResourceCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct setAdBlockingEnabledParams : public v8_crdtp::DeserializableProtocolObject<setAdBlockingEnabledParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setAdBlockingEnabledParams)
    V8_CRDTP_DESERIALIZE_FIELD("enabled", enabled),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAdBlockingEnabled(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAdBlockingEnabledParams params;
    setAdBlockingEnabledParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAdBlockingEnabled(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setAdBlockingEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setBypassCSPParams : public v8_crdtp::DeserializableProtocolObject<setBypassCSPParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setBypassCSPParams)
    V8_CRDTP_DESERIALIZE_FIELD("enabled", enabled),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setBypassCSP(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setBypassCSPParams params;
    setBypassCSPParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBypassCSP(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setBypassCSP"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setFontFamiliesParams : public v8_crdtp::DeserializableProtocolObject<setFontFamiliesParams> {
    std::unique_ptr<protocol::Page::FontFamilies> fontFamilies;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setFontFamiliesParams)
    V8_CRDTP_DESERIALIZE_FIELD("fontFamilies", fontFamilies),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setFontFamilies(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setFontFamiliesParams params;
    setFontFamiliesParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFontFamilies(std::move(params.fontFamilies));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setFontFamilies"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setFontSizesParams : public v8_crdtp::DeserializableProtocolObject<setFontSizesParams> {
    std::unique_ptr<protocol::Page::FontSizes> fontSizes;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setFontSizesParams)
    V8_CRDTP_DESERIALIZE_FIELD("fontSizes", fontSizes),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setFontSizes(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setFontSizesParams params;
    setFontSizesParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFontSizes(std::move(params.fontSizes));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setFontSizes"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setDocumentContentParams : public v8_crdtp::DeserializableProtocolObject<setDocumentContentParams> {
    String frameId;
    String html;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setDocumentContentParams)
    V8_CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    V8_CRDTP_DESERIALIZE_FIELD("html", html),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setDocumentContent(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setDocumentContentParams params;
    setDocumentContentParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setDocumentContent(params.frameId, params.html);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setDocumentContent"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setLifecycleEventsEnabledParams : public v8_crdtp::DeserializableProtocolObject<setLifecycleEventsEnabledParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setLifecycleEventsEnabledParams)
    V8_CRDTP_DESERIALIZE_FIELD("enabled", enabled),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setLifecycleEventsEnabled(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setLifecycleEventsEnabledParams params;
    setLifecycleEventsEnabledParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setLifecycleEventsEnabled(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setLifecycleEventsEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct startScreencastParams : public v8_crdtp::DeserializableProtocolObject<startScreencastParams> {
    Maybe<String> format;
    Maybe<int> quality;
    Maybe<int> maxWidth;
    Maybe<int> maxHeight;
    Maybe<int> everyNthFrame;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(startScreencastParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("everyNthFrame", everyNthFrame),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("format", format),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("maxHeight", maxHeight),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("maxWidth", maxWidth),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("quality", quality),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::startScreencast(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    startScreencastParams params;
    startScreencastParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->startScreencast(std::move(params.format), std::move(params.quality), std::move(params.maxWidth), std::move(params.maxHeight), std::move(params.everyNthFrame));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.startScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::stopLoading(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopLoading();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.stopLoading"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::stopScreencast(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopScreencast();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.stopScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setProduceCompilationCacheParams : public v8_crdtp::DeserializableProtocolObject<setProduceCompilationCacheParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setProduceCompilationCacheParams)
    V8_CRDTP_DESERIALIZE_FIELD("enabled", enabled),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setProduceCompilationCache(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setProduceCompilationCacheParams params;
    setProduceCompilationCacheParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setProduceCompilationCache(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setProduceCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct addCompilationCacheParams : public v8_crdtp::DeserializableProtocolObject<addCompilationCacheParams> {
    String url;
    Binary data;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(addCompilationCacheParams)
    V8_CRDTP_DESERIALIZE_FIELD("data", data),
    V8_CRDTP_DESERIALIZE_FIELD("url", url),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addCompilationCache(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addCompilationCacheParams params;
    addCompilationCacheParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addCompilationCache(params.url, params.data);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.addCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::clearCompilationCache(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->clearCompilationCache();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.clearCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct generateTestReportParams : public v8_crdtp::DeserializableProtocolObject<generateTestReportParams> {
    String message;
    Maybe<String> group;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(generateTestReportParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("group", group),
    V8_CRDTP_DESERIALIZE_FIELD("message", message),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::generateTestReport(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    generateTestReportParams params;
    generateTestReportParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->generateTestReport(params.message, std::move(params.group));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.generateTestReport"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::waitForDebugger(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->waitForDebugger();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.waitForDebugger"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setInterceptFileChooserDialogParams : public v8_crdtp::DeserializableProtocolObject<setInterceptFileChooserDialogParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setInterceptFileChooserDialogParams)
    V8_CRDTP_DESERIALIZE_FIELD("enabled", enabled),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setInterceptFileChooserDialog(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setInterceptFileChooserDialogParams params;
    setInterceptFileChooserDialogParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setInterceptFileChooserDialog(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Page.setInterceptFileChooserDialog"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>{
          { v8_crdtp::SpanFrom("Page.clearDeviceMetricsOverride"), v8_crdtp::SpanFrom("Emulation.clearDeviceMetricsOverride") },
          { v8_crdtp::SpanFrom("Page.clearDeviceOrientationOverride"), v8_crdtp::SpanFrom("DeviceOrientation.clearDeviceOrientationOverride") },
          { v8_crdtp::SpanFrom("Page.clearGeolocationOverride"), v8_crdtp::SpanFrom("Emulation.clearGeolocationOverride") },
          { v8_crdtp::SpanFrom("Page.deleteCookie"), v8_crdtp::SpanFrom("Network.deleteCookie") },
          { v8_crdtp::SpanFrom("Page.getCookies"), v8_crdtp::SpanFrom("Network.getCookies") },
          { v8_crdtp::SpanFrom("Page.setDeviceMetricsOverride"), v8_crdtp::SpanFrom("Emulation.setDeviceMetricsOverride") },
          { v8_crdtp::SpanFrom("Page.setDeviceOrientationOverride"), v8_crdtp::SpanFrom("DeviceOrientation.setDeviceOrientationOverride") },
          { v8_crdtp::SpanFrom("Page.setGeolocationOverride"), v8_crdtp::SpanFrom("Emulation.setGeolocationOverride") },
          { v8_crdtp::SpanFrom("Page.setTouchEmulationEnabled"), v8_crdtp::SpanFrom("Emulation.setTouchEmulationEnabled") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(v8_crdtp::SpanFrom("Page"), SortedRedirects(), std::move(dispatcher));
}

} // Page
} // namespace v8_inspector
} // namespace protocol
